{% extends 'base.html' %}
{% load static %}


{% block title %} Canvas {% endblock %}
{% block script %}
<script src="{% static 'konva/konva.min.js' %}"></script> {% endblock %}
{% block style %}
<style>
    body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        background-color: #f0f0f0;
    }
</style>
{% endblock %}

{% block content %}
<style>
    .toolbar-container {
        -webkit-box-pack: center;
        bottom: 15px;
        justify-content: center;
        display: flex;
        left: 0;
        margin: auto;
        position: absolute;
        right: 0;
        width: fit-content;
    }

    .toolbar {
        -webkit-box-pack: center;
        -webkit-box-align: center;
        background: floralwhite;
        align-items: center;
        border-radius: 32px;
        display: flex;
        font-family: Open sans, sans-serif;
        font-size: 12px;
        height: 40px;
        justify-content: center;
        padding: 0 5px;
        width: auto;
    }

    .toolbar .button-group {
        -webkit-box-align: center;
        align-items: center;
        -webkit-column-gap: 5px;
        column-gap: 5px;
        display: flex;
        height: 20px;
        padding: 0 5px;
    }

    .toolbar .button-group:not(:last-child) {
        border-right: 1px solid #000000;
        margin-left: 5px;
    }

    .toolbar .btn-outline-warning {
        margin-left: 0px;
        margin-top: 3px;
        margin-bottom: 3px;
        padding-right: 5px;
        padding-left: 7px;
        --bs-btn-border-color: #0000;
    }

</style>
<div id="container"></div>

<!-- Bottom Toolbar --->
<div class="toolbar-container">
    <div class="toolbar">
        <div class="button-group">
            <button class="btn btn-outline-warning zoom-out">
                <svg xmlns="http://www.w3.org/2000/svg" width="26" height="26" viewBox="0 0 26 26" fill="none"
                     class="icon">
                    <path xmlns="http://www.w3.org/2000/svg"
                          d="M2 12C2 11.4477 2.44772 11 3 11H21C21.5523 11 22 11.4477 22 12C22 12.5523 21.5523 13 21 13H3C2.44772 13 2 12.5523 2 12Z"
                          fill="black"/>
                </svg>
            </button>
            <span class="zoom-value" id="zoom-value">100%</span>
            <button class="btn btn-outline-warning zoom-in">
                <svg xmlns="http://www.w3.org/2000/svg" width="26" height="26" viewBox="0 0 26 26"
                     fill="none" class="icon">
                    <path xmlns="http://www.w3.org/2000/svg" d="M4 12H20M12 4V20" stroke="#000000" stroke-width="2"
                          stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
            </button>
        </div>
        <div class="button-group">
            <button class="btn btn-outline-warning new-state">
                <svg xmlns="http://www.w3.org/2000/svg" width="26" height="26" viewBox="0 0 26 26"
                     fill="none" class="icon">
                    <path xmlns="http://www.w3.org/2000/svg"
                          d="M8 12H16M12 8V16M21 12C21 16.9706 16.9706 21 12 21C7.02944 21 3 16.9706 3 12C3 7.02944 7.02944 3 12 3C16.9706 3 21 7.02944 21 12Z"
                          stroke="#000000" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path>
                </svg>
            </button>
            <button class="btn btn-outline-warning new-transition">
                <svg xmlns="http://www.w3.org/2000/svg" width="26" height="26" viewBox="0 0 26 26"
                     fill="none" class="icon">

                    <path xmlns="http://www.w3.org/2000/svg"
                          d="M13 3H12C7.02944 3 3 7.02944 3 12C3 16.9706 7.02944 21 12 21H13M17 8L21 12M21 12L17 16M21 12H9"
                          stroke="#000000" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path>

                </svg>
            </button>
            <button class="btn btn-outline-warning select-button">
                <svg xmlns="http://www.w3.org/2000/svg" width="26" height="26" viewBox="0 0 26 26"
                     fill="none" class="icon">

                    <path xmlns="http://www.w3.org/2000/svg"
                          d="M6.91304 19.4348L3 3L19.4348 6.91304L14.7391 10.0435L21 16.3043L16.3043 21L10.0435 14.7391L6.91304 19.4348Z"
                          stroke="#000000" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>


                </svg>
            </button>
            <button class="btn btn-outline-warning move-button">
                <svg height="26" viewBox="0 0 26 26" width="26" xmlns="http://www.w3.org/2000/svg"
                     class="icon">

                    <path xmlns="http://www.w3.org/2000/svg"
                          d="M12 3V9M12 3L9 6M12 3L15 6M12 15V21M12 21L15 18M12 21L9 18M3 12H9M3 12L6 15M3 12L6 9M15 12H21M21 12L18 9M21 12L18 15"
                          stroke="#000000" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>

                </svg>
            </button>
        </div>
        <div class="button-group">
            <button class="btn btn-outline-warning undo-button">
                <svg xmlns="http://www.w3.org/2000/svg" width="26" height="26" viewBox="0 -1 26 26"
                     fill="none" class="icon">

                    <path xmlns="http://www.w3.org/2000/svg"
                          d="M4 7H15C16.8692 7 17.8039 7 18.5 7.40193C18.9561 7.66523 19.3348 8.04394 19.5981 8.49999C20 9.19615 20 10.1308 20 12C20 13.8692 20 14.8038 19.5981 15.5C19.3348 15.9561 18.9561 16.3348 18.5 16.5981C17.8039 17 16.8692 17 15 17H8.00001M4 7L7 4M4 7L7 10"
                          stroke="#000000" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>

                </svg>
            </button>
            <button class="btn btn-outline-warning redo-button">
                <svg xmlns="http://www.w3.org/2000/svg" width="26" height="26" viewBox="0 -1 26 26"
                     fill="none" class="icon">


                    <path xmlns="http://www.w3.org/2000/svg"
                          d="M20 7H9.00001C7.13077 7 6.19615 7 5.5 7.40193C5.04395 7.66523 4.66524 8.04394 4.40193 8.49999C4 9.19615 4 10.1308 4 12C4 13.8692 4 14.8038 4.40192 15.5C4.66523 15.9561 5.04394 16.3348 5.5 16.5981C6.19615 17 7.13077 17 9 17H16M20 7L17 4M20 7L17 10"
                          stroke="#000000" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>


                </svg>
            </button>
        </div>
    </div>
</div>
<script>

    var width = window.innerWidth;
    var height = window.innerHeight;

    // stage here
    var stage = new Konva.Stage({container: 'container', width: width, height: height, draggable: false});

    // layer
    var layer = new Konva.Layer();

    var stateGroup = new Konva.Group();
    var transitionGroup = new Konva.Group();
    var anchorGroup = new Konva.Group();
    var textGroup = new Konva.Group({listening: false});

    var transitionDict = {};
    var stateDict = {};


    layer.add(transitionGroup, stateGroup, textGroup, anchorGroup);
    stage.add(layer);


    // Can we do something about all these global variables?
    var transitionId = 2;
    var stateId = 2;
    var anchorId = 0;
    var shiftToggle = false;
    var created = false;
    var endstate = null;
    var inside;
    var straigtening, selecting;
    var transitionTool = false;
    var stateTool = false;

    var anchor = new Konva.Circle({
        x: 0,
        y: 0,
        radius: 7,
        stroke: 'orange',
        strokeWidth: 3,
        hitStrokeWidth: 20,
        visible: false,
        draggable: true,
    });

    var transition = new Konva.Arrow({
        points: [0, 0, 0, 0],
        pointerLength: 20,
        pointerWidth: 20,
        name: 'transition',
        fill: 'black',
        stroke: 'black',
        strokeWidth: 5,
        lineJoin: 'round',
        tension: .45,
        hitStrokeWidth: 30,
    });

    function selected(item) {
        if (Object.keys(transitionDict).includes(item)) {
            selectTransition(item);
        }
        if (Object.keys(stateDict).includes(item)) {
            selectState(item);
        }
    }

    function selectTransition(transitionId) {
        // Make all the transition anchors invisible
        selecting = true;

        selectedItem = `transition${transitionId}`

        for (const [key, value] of Object.entries(transitionDict)) {
            value.setVisibility(false);
        }
        for (const [key, value] of Object.entries(stateDict)) {
            value.setStroke('black');
        }
        // Make the selected anchor visible
        console.log(`transition${transitionId}`);
        transitionDict[`transition${transitionId}`].setVisibility(true);
    }

    function selectState(stateId) {
        selecting = true;
        selectedItem = `state${stateId}`

        for (const [key, value] of Object.entries(transitionDict)) {
            value.setVisibility(false);
        }
        for (const [key, value] of Object.entries(stateDict)) {
            value.setStroke('black');
        }
        console.log(`state${stateId}`);
        stateDict[`state${stateId}`].setStroke('orange');
    }


    
    class State {



        constructor(x, y, id) {

            this.id = id;
            this.initialX = x;
            this.initialY = y;
            this.strokeCol = "black";

            this.state = new Konva.Circle({
                x: x,
                y: y,
                radius: 40,
                fill: 'white',
                stroke: this.strokeCol,
                strokeWidth: 3,
                name: "state",
                id: this.id,
                draggable: true,
            })


            this.text = new Konva.Text({
                x: this.state.position().x,
                y: this.state.position().y,
                text: `s${this.id}`,
                fontSize: 17,
            });

            this.addListeners();
            this.updateText('');
            stateGroup.add(this.state);
            textGroup.add(this.text);
        }

        addListeners() {

            this.state.addEventListener('mousedown', (evt) => {
                selectState(this.id);
            })

            this.state.addEventListener('dragmove', (evt) => {
                if ((evt.shiftKey) || (shiftToggle) || (transitionTool)) {
                    shiftToggle = true;
                    this.state.position({'x': this.initialX, 'y': this.initialY});
                    createTransition(this.state);
                } else {
                    // Actions when the state is moving
                    this.updateText('');
                    this.initialX = this.state.position().x;
                    this.initialY = this.state.position().y;
                    updateLines();
                }
            });


            this.state.addEventListener('dragend', function (evt) {
                if (shiftToggle) {
                    // When the arrow is connected to a state
                    if (inside) {
                        transitionDict[`transition${transitionId}`].addEndState(endstate)
                    } else {
                        transitionGroup.findOne(`#${transitionId}`).destroy();
                    }
                }
                shiftToggle = false;
                created = false;
            });
        }


        updateText(chr) {
            if (chr.charCodeAt(0) === 8) {
                this.text.text(this.text.text().substring(0, this.text.text().length - 1));
            } else {
                this.text.text(this.text.text() + chr);
            }

            this.text.position({
                x: this.state.position().x,
                y: this.state.position().y,
            });
            this.text.offset({
                x: this.text.width() / 2,
                y: this.text.height() / 2
            })

        }

        setStroke(col) {
            this.strokeCol = col;
            this.state.stroke(this.strokeCol);
        }

    }
    
     




    class Transition {
        constructor(startState, id) {
            this.startState = startState;
            this.anchor = anchor.clone();
            this.endState = null;
            this.id = id;

            this.transition = transition.clone({id: this.id, name: 'transition'});
            this.straightTransition = true;
            this.text = new Konva.Text({
                text: '',
                offsetY: 30,
                fontSize: 17,
            });
            this.addListeners();
            transitionGroup.add(this.transition)
        }


        addListeners() {
            this.transition.addEventListener('click', function () {
                selectTransition(this.id());
            })

            this.transition.addEventListener('dblclick', () => {
                this.setStraight(true);
                this.setVisibility(false);
                this.update();
                straigtening = true;
            });
        }


        setPoints(p) {
            this.points = p;
        }

        update() {

            if (this.straightTransition) {
                // Run when the transition is straight. Keeps the anchor in the middle between the states
                this.anchor.position({
                    x: (this.startState.position().x + this.endState.position().x) / 2,
                    y: (this.startState.position().y + this.endState.position().y) / 2,
                });

                let [endX, endY] = stayOnOutside(this.anchor.position().x, this.anchor.position().y,
                    this.endState.position().x, this.endState.position().y,
                    this.endState.radius())

                this.transition.points([this.startState.position().x, this.startState.position().y,
                    this.anchor.position().x, this.anchor.position().y,
                    endX, endY]);
            } else {
                // Run when the anchor isn't straight, keeps the anchor where it was before
                let [endX, endY] = stayOnOutside(this.anchor.position().x, this.anchor.position().y,
                    this.endState.position().x, this.endState.position().y,
                    this.endState.radius())
                this.transition.points([this.startState.position().x, this.startState.position().y,
                    this.anchor.position().x, this.anchor.position().y,
                    endX, endY]);
            }
            this.updateText('');
        }


        addEndState(endState, optional = null) {
            this.endState = endState;


            if (optional == null) {
                this.anchor = anchor.clone({
                    x: (this.startState.position().x + this.endState.position().x) / 2,
                    y: (this.startState.position().y + this.endState.position().y) / 2,
                    id: `anchor${++anchorId}`,
                });
            } else {
                this.anchor = optional;
            }

            this.anchor.addEventListener('dblclick', () => {
                this.setStraight(true);
                this.setVisibility(false);
                this.update();
                straigtening = true;
            });
            this.anchor.on('dragmove', (e) => {
                this.setStraight(false);
                updateLines()
            });

            textGroup.add(this.text);
            anchorGroup.add(this.anchor);
        }

        setVisibility(bool) {
            this.anchor.visible(bool);
            if (bool && (!selecting)) {
                this.setStraight(false);
            }
        }

        setStraight(bool) {
            this.straightTransition = bool;
        }


        updateText(chr) {

            if (chr.charCodeAt(0) === 8) { // Backspace
                this.text.text(this.text.text().substring(0, this.text.text().length - 1));
            } else {
                this.text.text(this.text.text() + chr);
            }
            this.text.position({
                x: this.anchor.position().x,
                y: this.anchor.position().y,
            });
            this.text.offsetX(this.text.width() / 2)
        }
    }

    function updateLines() {
        for (const [key, value] of Object.entries(transitionDict)) {
            value.update()
        }
        layer.draw();

    }

    function beginningFrame() {
        let state1 = new State(width / 4, height / 2 + 50, '1');
        let state2 = new State(width / 1.3, height / 2 - 50, '2');

        stateDict['state1'] = state1;
        stateDict['state2'] = state2;

        let transition1 = new Transition(state1.state, '1');
        let transition2 = new Transition(state2.state, '2');


        // Optional anchor to set the curve without user input
        let a1 = anchor.clone({
            x: (state1.state.position().x + state2.state.position().x) / 2,
            y: (state1.state.position().y + state2.state.position().y) / 2 - 100,
            id: `anchor${++anchorId}`
        })

        let a2 = anchor.clone({
            x: (state1.state.position().x + state2.state.position().x) / 2,
            y: (state1.state.position().y + state2.state.position().y) / 2 + 100,
        })


        transition1.addEndState(state2.state, a1);
        transition2.addEndState(state1.state, a2);

        transition1.updateText("1");
        transition2.updateText("0");

        transition1.setStraight(true);
        transition2.setStraight(false);

        console.log(transition1.anchor.position());

        transition1.update();
        transition2.update();


        transitionDict[`transition1`] = transition1;
        transitionDict['transition2'] = transition2;
    }


    var selectedItem = null;

    var container = stage.container();
    container.tabIndex = 1;

    container.addEventListener('keydown', function (e) {
        e.preventDefault();
        if (e.keyCode !== 16) { // Ignore SHIFT
            if (selectedItem != null) {

                let c = (String.fromCharCode(e.keyCode).toLowerCase());

                if (Object.keys(transitionDict).includes(selectedItem)) {
                    transitionDict[selectedItem].updateText(c)
                }

                if (Object.keys(stateDict).includes(selectedItem)) {
                    stateDict[selectedItem].updateText(c)
                }
            }
        }
    });


    stage.on('dblclick', function () {
        if (!straigtening) {
            ++stateId;
            stateDict[`state${stateId}`] = new State(stage.getRelativePointerPosition().x, stage.getRelativePointerPosition().y, stateId);
            layer.add(stateGroup);
        }
        straigtening = false;
    });


    stage.on('click', function () {

        if (stateTool && !straigtening && !selecting) {
            ++stateId;
            stateDict[`state${stateId}`] = new State(stage.getRelativePointerPosition().x, stage.getRelativePointerPosition().y, stateId);
            layer.add(stateGroup);
        }
        straigtening = false;
        selecting = false;
    })
    
    function distance(x1, y1, x2, y2) {
        let xdif = Math.pow((x2 - x1), 2);
        let ydif = Math.pow((y2 - y1), 2);
        return Math.sqrt(xdif + ydif);

    }

    function stayOnOutside(startX, startY, endX, endY, r) {
        let angle = Math.atan2((endY - startY), (endX - startX));
        let ydif = Math.sin(angle) * r;
        let xdif = Math.cos(angle) * r;

        return [(endX - xdif), (endY - ydif)];
    }

    function createTransition(startState) {

        if (!created) {
            var t = new Transition(startState, `${++transitionId}`);

            t.setPoints([startState.position().x, startState.position().y, stage.getRelativePointerPosition().x, stage.getRelativePointerPosition().y])
            transitionDict[`transition${t.id}`] = t;
            console.log(transitionDict);
            console.log(transitionId);
            created = true;

        } else {

            let current_draw = transitionDict[`transition${transitionId}`]
            var endPointX = stage.getRelativePointerPosition().x;
            var endPointY = stage.getRelativePointerPosition().y;

            inside = false;
            for (let state of stateGroup.children) {
                if (distance(endPointX, endPointY, state.position().x, state.position().y) < state.radius()) {
                    [endPointX, endPointY] = stayOnOutside(startState.position().x, startState.position().y,
                        state.position().x, state.position().y, state.radius())
                    endstate = state;
                    inside = true;
                }
            }

            current_draw.transition.setPoints([startState.position().x, startState.position().y, endPointX, endPointY])
            layer.add(transitionGroup);
            layer.draw();
        }
    }


    //    ----------- Tool Selection -----------


    $(document).on('click', '.zoom-out', function () {
        select("zoomOut");
    });
    $(document).on('click', '.zoom-in', function () {
        select("zoomIn");
    });
    $(document).on('click', '.select-button', function () {
        select("select");
    });
    $(document).on('click', '.move-button', function () {
        select("move");
    });
    $(document).on('click', '.new-transition', function () {
        select('transition');
    });
    $(document).on('click', '.new-state', function () {
        select('state');
    });

    function select(tool) {
        for (const [key, value] of Object.entries(transitionDict)) {
            value.setVisibility(false);
        }
        var oldScale = stage.scaleX();
        var scaleBy = 1.05;
        stage.container().style.cursor = 'default';
        stage.draggable(false);
        transitionTool = false;
        stateTool = false;
        selecting = false;

        switch (tool) {
            case "zoomIn":
                var newScale = oldScale * scaleBy;
                var moveTo = {
                    x: (width / 2 - stage.x()) / oldScale,
                    y: (height / 2 - stage.y()) / oldScale,
                };

                stage.scale({'x': oldScale * scaleBy, 'y': oldScale * scaleBy});

                var newPos = {
                    x: width / 2 - moveTo.x * newScale,
                    y: height / 2 - moveTo.y * newScale,
                };
                stage.position(newPos);
                document.getElementById("zoom-value").textContent = (Number(newScale * 100).toFixed(0)) + '%';
                break;

            case "zoomOut":
                var newScale = oldScale / scaleBy;
                var moveTo = {
                    x: (width / 2 - stage.x()) / oldScale,
                    y: (height / 2 - stage.y()) / oldScale,
                };

                stage.scale({'x': oldScale / scaleBy, 'y': oldScale / scaleBy});

                var newPos = {
                    x: width / 2 - moveTo.x * newScale,
                    y: height / 2 - moveTo.y * newScale,
                };
                stage.position(newPos);
                document.getElementById("zoom-value").textContent = (Number(newScale * 100).toFixed(0)) + '%';
                break;

            case "select":
                selecting = true;
                for (const [key, value] of Object.entries(transitionDict)) {
                    value.setVisibility(true);
                }
                break;
            case "move":
                stage.container().style.cursor = 'move';
                stage.draggable(true);
                break;
            case "state":
                stateTool = true;
                break;
            case "transition":
                transitionTool = true;
                break;
        }
    }

    beginningFrame();

</script>
{% endblock %}
